<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>黑白幾何遊戲 R3.1</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #000;
            color: #fff;
            font-family: 'Courier New', Courier, monospace;
            overflow: hidden;
            touch-action: none; /* 禁止預設觸控行為 */
            user-select: none; /* 禁止選取文字 */
            -webkit-user-select: none;
        }

        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        canvas {
            border: 2px solid #333;
            box-shadow: 0 0 15px rgba(255, 255, 255, 0.1);
        }

        /* UI 層 */
        #ui-layer {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 15px;
            box-sizing: border-box;
            z-index: 10;
        }

        .hud-text {
            color: #fff;
            font-size: 16px;
            text-shadow: 1px 1px 0 #000;
            pointer-events: auto;
        }

        /* 返回按鈕樣式 */
        #back-btn {
            pointer-events: auto;
            background: #fff;
            color: #000;
            border: none;
            padding: 8px 15px;
            font-weight: bold;
            font-size: 16px;
            font-family: inherit;
            display: none; /* 預設隱藏，遊戲中顯示 */
            margin-bottom: 10px;
            border-radius: 5px;
        }

        #center-msg {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            background: rgba(0,0,0,0.9);
            padding: 25px;
            border: 2px solid white;
            display: block; /* 初始顯示 */
            pointer-events: auto;
            min-width: 250px;
            box-shadow: 0 0 20px rgba(255,255,255,0.2);
        }
        
        #tap-feedback {
            color: yellow;
            font-weight: bold;
            font-size: 20px;
            margin-top: 10px;
            min-height: 24px;
        }

        /* 隱藏關卡專用音量滑桿 */
        #volume-control {
            display: none;
            width: 80%;
            margin: 0 auto;
            pointer-events: auto;
        }

        /* 黑屏遮罩 */
        #black-screen {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background-color: #000;
            z-index: 9999;
            display: none;
            color: #111;
            display: flex;
            align-items: center;
            justify-content: center;
            pointer-events: auto;
        }
        
        button {
            cursor: pointer;
        }
    </style>
</head>
<body>

<div id="game-container">
    <canvas id="gameCanvas"></canvas>
    
    <div id="ui-layer">
        <div>
            <button id="back-btn" onclick="returnToMenu()">⬅ 回主選單</button>
            <div class="hud-text" id="top-hud"></div>
        </div>
        
        <div id="center-msg">
            <h2 style="margin-top:0;">黑白幾何 R3</h2>
            <hr>
            <p style="font-weight:bold;">操作指令：</p>
            <ul style="text-align:left; font-size:15px; line-height:1.6;">
                <li><strong>點 3 下</strong>：開始遊戲</li>
                <li>點 5 下：儲存紀錄</li>
                <li>點 2 下：放棄/重置</li>
                <li>點 1 下：確定/購買</li>
            </ul>
            <div id="tap-feedback">請點擊螢幕操作</div>
            <p style="font-size:12px; color:#aaa; margin-top:15px;">提示：初始10金幣<br>每1金幣增加10%速度</p>
        </div>

        <div class="hud-text" style="text-align: center;">
            <input type="range" id="volume-control" min="0" max="100" value="100">
            <br>
            <span id="bottom-hud">金幣: 10</span>
            <br>
            <button id="screen-toggle-btn" style="pointer-events:auto; margin-top:10px; background:black; color:white; border:1px solid white; padding:5px 10px;">隱藏螢幕</button>
        </div>
    </div>
</div>

<div id="black-screen">
    (已隱藏：點擊此處喚醒)
</div>

<script>
/**
 * 遊戲全域變數與設定
 */
const CONFIG = {
    unitScale: 10, // 螢幕寬度的 1/10
    tapDelay: 500, // 放寬判定多點擊的間隔(ms)，讓操作更容易
    coinCost: 100  // 換音效價格
};

const STATE = {
    scene: 'MENU', // MENU, GAME, HIDDEN, SHOP
    level: 1,
    maxLevels: 100,
    coins: 10, // 初始 10 金幣
    player: { x: 0, y: 0, vx: 0, vy: 0, soundType: 0 },
    shape: null, // 當前關卡的幾何資訊
    objects: [], // 金幣, 出口, 旗子
    volume: 100, // 模擬音量
    doorOpen: false,
    tapCount: 0,
    tapTimer: null,
    hiddenUnlocked: false,
    menuAnimAngle: 0 // 主畫面動畫用
};

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

// 音效系統
const AudioSys = {
    ctx: new (window.AudioContext || window.webkitAudioContext)(),
    
    playTone: function(freq, type, duration, vol=0.1) {
        if (this.ctx.state === 'suspended') this.ctx.resume();
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.type = type;
        osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
        gain.gain.setValueAtTime(vol, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);
        osc.connect(gain);
        gain.connect(this.ctx.destination);
        osc.start();
        osc.stop(this.ctx.currentTime + duration);
    },

    speak: function(text) {
        if ('speechSynthesis' in window) {
            window.speechSynthesis.cancel(); 
            const utterance = new SpeechSynthesisUtterance(text);
            utterance.lang = 'en-US'; 
            utterance.rate = 1.0; 
            window.speechSynthesis.speak(utterance);
        }
    },

    hit: () => AudioSys.playTone(150, 'sawtooth', 0.1, 0.3),
    step: () => {
        let baseFreq = 200 + (STATE.player.soundType * 100);
        AudioSys.playTone(baseFreq, 'square', 0.05, 0.1); 
    }, 
    coin: () => {
        AudioSys.playTone(1200, 'sine', 0.1, 0.2);
        setTimeout(() => AudioSys.playTone(1800, 'sine', 0.2, 0.2), 50);
    },
    door: () => AudioSys.playTone(100, 'triangle', 1.0, 0.4),
    win: () => {
        [523, 659, 783, 1046].forEach((f, i) => {
            setTimeout(() => AudioSys.playTone(f, 'sine', 0.3, 0.3), i * 150);
        });
    },
    teleport: () => {
        AudioSys.playTone(800, 'sawtooth', 0.5, 0.3);
        setTimeout(() => AudioSys.playTone(200, 'sawtooth', 0.5, 0.3), 200);
    }
};

/**
 * 幾何圖形生成邏輯
 */
function createShape(level, width, height) {
    const cx = width / 2;
    const cy = height / 2;
    const r = Math.min(width, height) * 0.4;
    let type = '';
    let vertices = [];

    let shapeIdx = Math.floor(Math.random() * 8);
    
    if (level === 101) shapeIdx = 2; // 隱藏關圓形

    switch(shapeIdx) {
        case 0: type = 'poly'; vertices = createPoly(cx, cy, r, 4, Math.PI/4); break;
        case 1: type = 'poly'; vertices = createPoly(cx, cy, r, 4, 0); break;
        case 2: type = 'circle'; break;
        case 3: type = 'poly'; vertices = createPoly(cx, cy, r, 3, -Math.PI/2); break;
        case 4: type = 'rect'; break;
        case 5: type = 'poly'; vertices = createPoly(cx, cy, r, 5, -Math.PI/2); break;
        case 6: type = 'poly'; vertices = createPoly(cx, cy, r, 6, 0); break;
        case 7: type = 'poly'; vertices = createPoly(cx, cy, r, 8, Math.PI/8); break;
    }

    if (type === 'rect') {
        let w = r * 1.5;
        let h = r * 0.8;
        vertices = [
            {x: cx - w, y: cy - h},
            {x: cx + w, y: cy - h},
            {x: cx + w, y: cy + h},
            {x: cx - w, y: cy + h}
        ];
        type = 'poly';
    }

    return { type, cx, cy, r, vertices };
}

function createPoly(cx, cy, r, sides, rotation) {
    let verts = [];
    for (let i = 0; i < sides; i++) {
        let angle = rotation + (i * 2 * Math.PI / sides);
        verts.push({
            x: cx + r * Math.cos(angle),
            y: cy + r * Math.sin(angle)
        });
    }
    return verts;
}

function isInside(x, y, shape) {
    if (shape.type === 'circle') {
        let dist = Math.sqrt((x - shape.cx)**2 + (y - shape.cy)**2);
        return dist < shape.r;
    } else {
        let inside = false;
        let vs = shape.vertices;
        for (let i = 0, j = vs.length - 1; i < vs.length; j = i++) {
            let xi = vs[i].x, yi = vs[i].y;
            let xj = vs[j].x, yj = vs[j].y;
            let intersect = ((yi > y) != (yj > y)) &&
                (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
            if (intersect) inside = !inside;
        }
        return inside;
    }
}

/**
 * 關卡初始化
 */
function initLevel(levelNum) {
    STATE.level = levelNum;
    STATE.doorOpen = false;
    STATE.objects = [];
    
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    
    STATE.shape = createShape(levelNum, canvas.width, canvas.height);
    STATE.player.x = canvas.width / 2;
    STATE.player.y = canvas.height / 2;

    let unit = canvas.width / 10;

    // 1. 放置出口 (3個)
    for(let i=0; i<3; i++) {
        let exitPos = getRandomPosInShape();
        if(dist(exitPos.x, exitPos.y, STATE.player.x, STATE.player.y) > 50) {
             STATE.objects.push({ type: 'exit', x: exitPos.x, y: exitPos.y, r: 15 });
        } else {
             i--; 
        }
    }

    // 2. 放置金幣
    let boundR = STATE.shape.r;
    let cx = STATE.shape.cx;
    let cy = STATE.shape.cy;
    let step = 40; 
    for (let dy = -boundR; dy <= boundR; dy += step) {
        for (let dx = -boundR; dx <= boundR; dx += step) {
            let tx = cx + dx;
            let ty = cy + dy;
            tx += (Math.random() - 0.5) * 10;
            ty += (Math.random() - 0.5) * 10;

            if (isInside(tx, ty, STATE.shape)) {
                if (dist(tx, ty, STATE.player.x, STATE.player.y) > 30) {
                    let clear = true;
                    STATE.objects.forEach(o => {
                        if(o.type === 'exit' && dist(tx, ty, o.x, o.y) < 30) clear = false;
                    });
                    if(clear) STATE.objects.push({ type: 'coin', x: tx, y: ty, r: 5 });
                }
            }
        }
    }

    // 3. 第一關特殊物件：旗子
    if (STATE.level === 1) {
        let angle = Math.random() * Math.PI * 2;
        let flagDist = unit * 3.5; 
        let fx = STATE.player.x + Math.cos(angle) * flagDist;
        let fy = STATE.player.y + Math.sin(angle) * flagDist;
        
        if (!isInside(fx, fy, STATE.shape)) {
             let valid = getRandomPosInShape();
             fx = valid.x; fy = valid.y;
        }
        STATE.objects.push({ type: 'flag', x: fx, y: fy, r: 10 });
    }

    // UI 更新
    document.getElementById('top-hud').innerText = (STATE.level === 101) ? "隱藏關卡" : `Level ${STATE.level}/100`;
    document.getElementById('center-msg').style.display = 'none';
    document.getElementById('back-btn').style.display = 'block'; 
    
    // 隱藏關卡特殊UI
    let volCtrl = document.getElementById('volume-control');
    if (STATE.level === 101) {
        volCtrl.style.display = 'inline-block';
        document.getElementById('top-hud').innerText = "隱藏關卡：請將音量調至最低";
        AudioSys.speak("Hidden Stage Start");
    } else {
        volCtrl.style.display = 'none';
        AudioSys.speak(`Level ${STATE.level} Start`);
    }
}

function getRandomPosInShape() {
    let x, y;
    let limit = 0;
    do {
        x = canvas.width/2 + (Math.random() - 0.5) * STATE.shape.r * 2;
        y = canvas.height/2 + (Math.random() - 0.5) * STATE.shape.r * 2;
        limit++;
    } while (!isInside(x, y, STATE.shape) && limit < 100);
    return {x, y};
}

function dist(x1, y1, x2, y2) {
    return Math.sqrt((x1-x2)**2 + (y1-y2)**2);
}

/**
 * 遊戲主迴圈
 */
function update() {
    // 主畫面動畫更新
    if (STATE.scene === 'MENU') {
        STATE.menuAnimAngle += 0.02;
        return;
    }

    if (STATE.scene !== 'GAME' && STATE.scene !== 'HIDDEN') return;

    // --- 速度控制邏輯 ---
    let baseSpeedFactor = 0.08; 
    let levelMultiplier = (STATE.level > 1) ? 2.0 : 1.0;
    let coinMultiplier = 1 + (STATE.coins * 0.1);
    let speed = (canvas.width / 10) * baseSpeedFactor * levelMultiplier * coinMultiplier;
    
    // 移動
    let nextX = STATE.player.x + STATE.player.vx * speed;
    let nextY = STATE.player.y + STATE.player.vy * speed;

    if (isInside(nextX, nextY, STATE.shape)) {
        if (Math.abs(nextX - STATE.player.x) > 0.5 || Math.abs(nextY - STATE.player.y) > 0.5) {
            if (Math.random() > 0.9) AudioSys.step();
        }
        STATE.player.x = nextX;
        STATE.player.y = nextY;
    } else {
        if (Math.abs(STATE.player.vx) > 0.1 || Math.abs(STATE.player.vy) > 0.1) {
             if (Math.random() > 0.8) AudioSys.hit();
        }
    }

    // 碰撞
    for (let i = STATE.objects.length - 1; i >= 0; i--) {
        let obj = STATE.objects[i];
        if (dist(STATE.player.x, STATE.player.y, obj.x, obj.y) < (obj.r + 5)) {
            if (obj.type === 'coin') {
                STATE.coins++;
                AudioSys.coin();
                STATE.objects.splice(i, 1);
                updateCoinDisplay();
            } 
            else if (obj.type === 'flag') {
                AudioSys.teleport();
                alert("發現旗子！傳送至隱藏關卡！");
                STATE.scene = 'HIDDEN';
                initLevel(101);
                return;
            } 
            else if (obj.type === 'exit') {
                if (STATE.level === 101 && !STATE.doorOpen) {
                } else {
                    levelComplete();
                }
            }
        }
    }

    if (STATE.level === 101) {
        let vol = document.getElementById('volume-control').value;
        if (vol < 5 && !STATE.doorOpen) {
            STATE.doorOpen = true;
            AudioSys.door();
            document.getElementById('top-hud').innerText = "出口已開啟！";
        }
    }
}

function levelComplete() {
    AudioSys.win();
    STATE.level++;
    if (STATE.level > CONFIG.maxLevels && STATE.level !== 102) { 
        STATE.scene = 'HIDDEN';
        alert("恭喜通關100層！解鎖隱藏關卡！");
        initLevel(101);
    } else if (STATE.level === 102) { 
        alert("全遊戲通關！恭喜！");
        returnToMenu();
        resetGame();
    } else {
        initLevel(STATE.level);
    }
}

function draw() {
    ctx.fillStyle = '#000';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // 主畫面繪製 (解決畫面全黑問題)
    if (STATE.scene === 'MENU') {
        let cx = canvas.width / 2;
        let cy = canvas.height / 2;
        let r = Math.min(canvas.width, canvas.height) * 0.3;
        
        ctx.save();
        ctx.translate(cx, cy);
        ctx.rotate(STATE.menuAnimAngle);
        ctx.strokeStyle = '#333';
        ctx.lineWidth = 2;
        ctx.beginPath();
        for(let i=0; i<6; i++) {
            let angle = (i * 2 * Math.PI / 6);
            ctx.lineTo(r * Math.cos(angle), r * Math.sin(angle));
        }
        ctx.closePath();
        ctx.stroke();
        ctx.restore();
        return; 
    }

    if (STATE.shape) {
        ctx.fillStyle = '#fff';
        if (STATE.shape.type === 'circle') {
            ctx.beginPath();
            ctx.arc(STATE.shape.cx, STATE.shape.cy, STATE.shape.r, 0, Math.PI*2);
            ctx.fill();
        } else {
            ctx.beginPath();
            STATE.shape.vertices.forEach((v, i) => {
                if (i===0) ctx.moveTo(v.x, v.y);
                else ctx.lineTo(v.x, v.y);
            });
            ctx.closePath();
            ctx.fill();
        }
    }

    STATE.objects.forEach(obj => {
        if (obj.type === 'exit') {
            ctx.fillStyle = (STATE.level === 101 && !STATE.doorOpen) ? '#555' : '#000';
            ctx.fillRect(obj.x - 10, obj.y - 10, 20, 20);
            ctx.fillStyle = '#fff';
            ctx.font = '12px Arial';
            ctx.fillText("EXIT", obj.x-12, obj.y-12);
        } else if (obj.type === 'coin') {
            ctx.fillStyle = '#000'; 
            ctx.beginPath();
            ctx.arc(obj.x, obj.y, obj.r, 0, Math.PI*2);
            ctx.fill();
            ctx.strokeStyle = '#000';
            ctx.stroke();
        } else if (obj.type === 'flag') {
            ctx.fillStyle = '#000';
            ctx.font = '20px Arial';
            ctx.fillText("⚑", obj.x-5, obj.y+5);
        }
    });

    ctx.fillStyle = '#000';
    ctx.beginPath();
    ctx.arc(STATE.player.x, STATE.player.y, 6, 0, Math.PI*2);
    ctx.fill();
    ctx.strokeStyle = '#888'; 
    ctx.lineWidth = 1;
    ctx.stroke();

    requestAnimationFrame(draw);
}

function gameLoop() {
    update();
    draw();
    setTimeout(gameLoop, 1000/60);
}

function returnToMenu() {
    STATE.scene = 'MENU';
    document.getElementById('center-msg').style.display = 'block';
    document.getElementById('tap-feedback').innerText = "遊戲暫停 (點3下繼續)";
    document.getElementById('volume-control').style.display = 'none';
    document.getElementById('back-btn').style.display = 'none';
    document.getElementById('top-hud').innerText = "";
}

/**
 * 輸入控制系統
 */
// 重力感應
window.addEventListener('deviceorientation', (e) => {
    let y = e.beta; 
    let x = e.gamma;
    if (x > 45) x = 45; if (x < -45) x = -45;
    if (y > 45) y = 45; if (y < -45) y = -45;
    STATE.player.vx = x / 45;
    STATE.player.vy = y / 45;
});

// 觸控指令
document.getElementById('game-container').addEventListener('click', (e) => {
    if (e.target.tagName === 'BUTTON' || e.target.tagName === 'INPUT') return;

    STATE.tapCount++;
    
    // 更新回饋文字
    let fb = document.getElementById('tap-feedback');
    fb.style.color = 'yellow';
    
    if (STATE.scene === 'MENU') {
        fb.innerText = `點擊次數: ${STATE.tapCount} / 3 (開始)`;
    } else {
        fb.innerText = `點擊次數: ${STATE.tapCount}`;
    }

    clearTimeout(STATE.tapTimer);
    
    STATE.tapTimer = setTimeout(() => {
        handleTapCommand(STATE.tapCount);
        STATE.tapCount = 0;
        // 延遲後重置文字
        setTimeout(() => {
            if(STATE.scene === 'MENU') fb.innerText = "請點擊螢幕操作";
        }, 1000);
    }, CONFIG.tapDelay);
});

function handleTapCommand(count) {
    let fb = document.getElementById('tap-feedback');
    
    if (STATE.scene === 'MENU') {
        if (count === 3) {
            fb.innerText = "開始遊戲！";
            fb.style.color = '#0f0';
            setTimeout(() => {
                STATE.scene = 'GAME';
                initLevel(STATE.level); 
            }, 500);
        } 
        else if (count === 2) { 
            if (confirm("要重置進度回到第1關嗎？")) {
                STATE.level = 1;
                STATE.coins = 10; 
                updateCoinDisplay();
                alert("進度已重置");
            }
        }
        else if (count === 5) { 
            localStorage.setItem('bwGameSave', JSON.stringify({
                level: STATE.level,
                coins: STATE.coins
            }));
            alert("遊戲紀錄已儲存！");
        }
        else if (count === 1) { 
            if (STATE.coins >= CONFIG.coinCost) {
                if(confirm(`是否花費 ${CONFIG.coinCost} 金幣更換移動音效？`)) {
                    STATE.coins -= CONFIG.coinCost;
                    STATE.player.soundType = (STATE.player.soundType + 1) % 5;
                    updateCoinDisplay();
                    alert("購買成功！");
                }
            } else {
                // 如果只是誤觸1下，不做反應，避免干擾
            }
        }
    } 
    else if (STATE.scene === 'GAME' || STATE.scene === 'HIDDEN') {
        if (count === 4) { 
            returnToMenu();
        }
    }
}

function updateCoinDisplay() {
    document.getElementById('bottom-hud').innerText = `金幣: ${STATE.coins}`;
}

function resetGame() {
    STATE.level = 1;
    STATE.coins = 10;
    document.getElementById('center-msg').style.display = 'block';
    updateCoinDisplay();
}

/**
 * 螢幕隱藏
 */
const blackScreen = document.getElementById('black-screen');
document.getElementById('screen-toggle-btn').addEventListener('click', () => {
    blackScreen.style.display = 'flex';
});

blackScreen.addEventListener('click', () => {
    blackScreen.style.display = 'none';
});

const savedData = localStorage.getItem('bwGameSave');
if (savedData) {
    const data = JSON.parse(savedData);
    STATE.level = data.level || 1;
    STATE.coins = (data.coins !== undefined) ? data.coins : 10;
    updateCoinDisplay();
} else {
    updateCoinDisplay();
}

canvas.width = window.innerWidth;
canvas.height = window.innerHeight;
// 啟動
gameLoop();

// 權限
document.addEventListener('click', async () => {
    if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
        try { await DeviceOrientationEvent.requestPermission(); } catch (e) {}
    }
}, { once: true });

</script>
</body>
</html>